{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Cosmo-ML-Tools","text":""},{"location":"#a-cosmology-machine-learning-toolbox","title":"A Cosmology &amp; Machine Learning Toolbox","text":"<p>An attempt to wrap many useful python packagages, ML algorithms and automate common workflows in Cosmology.</p> <p>DISCLAIMER: This is very much work in progress. It is originally intended for my own use, so the documentation might not be as good as I would like it to be.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://rcalderonb6.github.io/cosmo-ml-tools</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"analysis/","title":"Analysis module","text":"<p>Analysis Module.</p>"},{"location":"analysis/#cosmo_ml_tools.analysis.analysis","title":"<code>analysis</code>","text":""},{"location":"analysis/#cosmo_ml_tools.analysis.analysis.Analysis","title":"<code> Analysis            (AnalysisBase)         </code>","text":"Source code in <code>cosmo_ml_tools/analysis/analysis.py</code> <pre><code>class Analysis(AnalysisBase):\n\n    def load(self):\n        self._chains=load_chains(self.chains,self.labels)\n\n    def add_chain(self, chain: str, label: str=None, root: str='',index:int=-1):\n        if label is None: \n            label='chain0'\n            self._chains.update(load_chains([chain],[label],root=root))\n        else:\n            pass\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.analysis.Analysis.add_chain","title":"<code>add_chain(self, chain, label=None, root='', index=-1)</code>","text":"<p>Append a chain to the list of loaded chains (at the specified index, default last)</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>str</code> <p>description</p> required <code>label</code> <code>str</code> <p>description</p> <code>None</code> <code>root</code> <code>str</code> <p>description</p> <code>''</code> <code>index</code> <code>int</code> <p>description</p> <code>-1</code> Source code in <code>cosmo_ml_tools/analysis/analysis.py</code> <pre><code>def add_chain(self, chain: str, label: str=None, root: str='',index:int=-1):\n    if label is None: \n        label='chain0'\n        self._chains.update(load_chains([chain],[label],root=root))\n    else:\n        pass\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.analysis.Analysis.load","title":"<code>load(self)</code>","text":"<p>Load a given set of chains.</p> Source code in <code>cosmo_ml_tools/analysis/analysis.py</code> <pre><code>def load(self):\n    self._chains=load_chains(self.chains,self.labels)\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base","title":"<code>base</code>","text":""},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase","title":"<code> AnalysisBase            (ABC)         </code>","text":"<p>Abstract Analysis Class</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>class AnalysisBase(ABC):\n    \"\"\"\n    Abstract Analysis Class\n    \"\"\"\n    def __init__(self) -&gt; None:\n        pass\n\n    def set_labels(self,labels) -&gt; None:\n        self._labels=labels\n\n    @abstractmethod\n    def computeEvidence(self,chain:str=None) -&gt; None:\n        \"\"\"\n        Compute the Bayesian Evidence for the chains using ``Harmonic``.\n        This might be a time-comsuming method, make sure to properly read the documentation\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def load(self,chains:list[str]) -&gt; None:\n        \"\"\"\n        Load a given set of chains.\n        \"\"\"\n        ...    \n\n    @abstractmethod\n    def add_chain(chain:str,label:str,root:str,index:int=-1):\n        \"\"\"Append a chain to the list of loaded chains (at the specified index, default last)\n\n        Args:\n            chain (str): _description_\n            label (str): _description_\n            root (str): _description_\n            index (int): _description_\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def plot_triangle(self,params:list[str]=None):\n        \"\"\"\n        Triangle plot for the specified subset of parameters.\n        \"\"\"\n        ...    \n\n    @abstractmethod\n    def plot_2D(self,params:list[str]):\n        \"\"\"\n        Plot the 2D marginalized posteriors.\n        \"\"\"\n        ...    \n\n    @abstractmethod\n    def plot_posterior_y(self,x,f,theta):\n        \"\"\"\n        Plot the posterior distribution of a given function y = f(x,theta)\n        from MCMC samples of theta using the ``f_given_x`` package.\n        \"\"\"\n        ...    \n\n    @abstractmethod\n    def _getGelmanRubin(self):\n        \"\"\"Computee the Gelman-Rubin (R-1) statistics for the chains\"\"\"\n        ...   \n\n    @abstractmethod\n    def getInfo(self):\n        \"\"\"\n        Print useful information about the chains loaded.\n        \"\"\"\n        ...    \n\n    @abstractmethod\n    def set_aliases(self,aliases:dict) -&gt; None:\n        \"\"\"\n        Set aliases for the chains\n        \"\"\"\n        ...        \n\n    @property\n    def GelmanRubin(self) -&gt; list:\n        \"\"\"\n        Gelman Rubin (R-1) statistics for the chains loaded.\n        \"\"\"\n        self._getGelmanRubin(self)\n\n    @property\n    def chains(self) -&gt; dict:\n        \"\"\"\n        The chains stored as a dictionary with labels as keys.\n        \"\"\"\n        return self._chains\n\n    @property\n    def labels(self) -&gt; list:\n        \"\"\"\n        Labels for the chains that are loaded.\n        \"\"\"\n        return self._labels\n\n    @property\n    def filenames(self)-&gt; list:\n        \"\"\"\n        List of filenames for the chains, as stored on the disk.\n        \"\"\"\n        return self._filenames\n\n    @property\n    def N(self) -&gt; int:\n        \"\"\"\n        Number of chains loaded.\n        \"\"\"\n        return len(self._labels)\n\n    @property\n    def logZ(self) -&gt; int:\n        \"\"\"\n        Bayesian Evidence (if computed).\n        \"\"\"\n        return [c.logZ for c in self._chains]\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.GelmanRubin","title":"<code>GelmanRubin: list</code>  <code>property</code> <code>readonly</code>","text":"<p>Gelman Rubin (R-1) statistics for the chains loaded.</p>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.N","title":"<code>N: int</code>  <code>property</code> <code>readonly</code>","text":"<p>Number of chains loaded.</p>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.chains","title":"<code>chains: dict</code>  <code>property</code> <code>readonly</code>","text":"<p>The chains stored as a dictionary with labels as keys.</p>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.filenames","title":"<code>filenames: list</code>  <code>property</code> <code>readonly</code>","text":"<p>List of filenames for the chains, as stored on the disk.</p>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.labels","title":"<code>labels: list</code>  <code>property</code> <code>readonly</code>","text":"<p>Labels for the chains that are loaded.</p>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.logZ","title":"<code>logZ: int</code>  <code>property</code> <code>readonly</code>","text":"<p>Bayesian Evidence (if computed).</p>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.add_chain","title":"<code>add_chain(chain, label, root, index=-1)</code>","text":"<p>Append a chain to the list of loaded chains (at the specified index, default last)</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>str</code> <p>description</p> required <code>label</code> <code>str</code> <p>description</p> required <code>root</code> <code>str</code> <p>description</p> required <code>index</code> <code>int</code> <p>description</p> <code>-1</code> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef add_chain(chain:str,label:str,root:str,index:int=-1):\n    \"\"\"Append a chain to the list of loaded chains (at the specified index, default last)\n\n    Args:\n        chain (str): _description_\n        label (str): _description_\n        root (str): _description_\n        index (int): _description_\n    \"\"\"\n    ...\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.computeEvidence","title":"<code>computeEvidence(self, chain=None)</code>","text":"<p>Compute the Bayesian Evidence for the chains using <code>Harmonic</code>. This might be a time-comsuming method, make sure to properly read the documentation</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef computeEvidence(self,chain:str=None) -&gt; None:\n    \"\"\"\n    Compute the Bayesian Evidence for the chains using ``Harmonic``.\n    This might be a time-comsuming method, make sure to properly read the documentation\n    \"\"\"\n    ...\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.getInfo","title":"<code>getInfo(self)</code>","text":"<p>Print useful information about the chains loaded.</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef getInfo(self):\n    \"\"\"\n    Print useful information about the chains loaded.\n    \"\"\"\n    ...    \n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.load","title":"<code>load(self, chains)</code>","text":"<p>Load a given set of chains.</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef load(self,chains:list[str]) -&gt; None:\n    \"\"\"\n    Load a given set of chains.\n    \"\"\"\n    ...    \n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.plot_2D","title":"<code>plot_2D(self, params)</code>","text":"<p>Plot the 2D marginalized posteriors.</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef plot_2D(self,params:list[str]):\n    \"\"\"\n    Plot the 2D marginalized posteriors.\n    \"\"\"\n    ...    \n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.plot_posterior_y","title":"<code>plot_posterior_y(self, x, f, theta)</code>","text":"<p>Plot the posterior distribution of a given function y = f(x,theta) from MCMC samples of theta using the <code>f_given_x</code> package.</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef plot_posterior_y(self,x,f,theta):\n    \"\"\"\n    Plot the posterior distribution of a given function y = f(x,theta)\n    from MCMC samples of theta using the ``f_given_x`` package.\n    \"\"\"\n    ...    \n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.plot_triangle","title":"<code>plot_triangle(self, params=None)</code>","text":"<p>Triangle plot for the specified subset of parameters.</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef plot_triangle(self,params:list[str]=None):\n    \"\"\"\n    Triangle plot for the specified subset of parameters.\n    \"\"\"\n    ...    \n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.AnalysisBase.set_aliases","title":"<code>set_aliases(self, aliases)</code>","text":"<p>Set aliases for the chains</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef set_aliases(self,aliases:dict) -&gt; None:\n    \"\"\"\n    Set aliases for the chains\n    \"\"\"\n    ...        \n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.ChainBase","title":"<code> ChainBase            (ABC)         </code>","text":"<p>Abstract Base Chain Class</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>class ChainBase(ABC):\n    \"\"\"\n    Abstract Base Chain Class\n    \"\"\"\n    def __init__(self):\n        self._evidence=None\n        pass\n\n    @abstractmethod\n    def load(self):\n        \"\"\"Load the chain using the engine of your choice\"\"\"\n        ...\n\n    @abstractmethod\n    def to_harmonic(self):\n        \"\"\"\n        A method that returns the samples and corresponding posterior values in a Harmonic-friendly format.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def set_param_labels(self,labels:list[str]):\n        \"\"\"Set the labels for the parameters\"\"\"\n        ...\n\n    @abstractmethod\n    def set_label(self):\n        \"\"\"Set the label for the chain\"\"\"\n        ...\n\n    @abstractmethod\n    def get_logZ(self):\n        \"\"\"Get the Bayesian Evidence for the chain\"\"\"\n        ...\n\n\n    @abstractmethod\n    def set_alias(self):\n        \"\"\"\n        Set an alias, or shorter name of the chain for quickly reference (useful for long data combinations)\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def getInfo(self):\n        \"\"\"\n        Print a summary of useful information on the chain.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def getTable(self,params:list):\n        \"\"\"\n        Print a latex table with the mean and 68% CL.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def trace(self,params:list,*args,**kwargs):\n        \"\"\"Produce a trace plot of the chain for the requested parameters.\n        i.e. The evolution of the parameter values as a function of the iteration number.\n\n\n        Args:\n            params (list): A list of sampled (or derived) parameters to inspect\n        \"\"\"\n        ...\n\n    @abstractmethod    \n    def getMinimum(self,*args,**kwargs):\n        \"\"\"\n        Get the minimum chi2 point from the chain\n        \"\"\"\n        ...\n\n    @property \n    def logZ(self):\n        \"\"\"\n        Log-Bayesian Evidence\n        \"\"\"\n        try:\n            self.get_logZ()\n        except BayesianEvidenceNotFound as err:\n            print(err)\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.ChainBase.logZ","title":"<code>logZ</code>  <code>property</code> <code>readonly</code>","text":"<p>Log-Bayesian Evidence</p>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.ChainBase.getInfo","title":"<code>getInfo(self)</code>","text":"<p>Print a summary of useful information on the chain.</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef getInfo(self):\n    \"\"\"\n    Print a summary of useful information on the chain.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.ChainBase.getMinimum","title":"<code>getMinimum(self, *args, **kwargs)</code>","text":"<p>Get the minimum chi2 point from the chain</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod    \ndef getMinimum(self,*args,**kwargs):\n    \"\"\"\n    Get the minimum chi2 point from the chain\n    \"\"\"\n    ...\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.ChainBase.getTable","title":"<code>getTable(self, params)</code>","text":"<p>Print a latex table with the mean and 68% CL.</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef getTable(self,params:list):\n    \"\"\"\n    Print a latex table with the mean and 68% CL.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.ChainBase.get_logZ","title":"<code>get_logZ(self)</code>","text":"<p>Get the Bayesian Evidence for the chain</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef get_logZ(self):\n    \"\"\"Get the Bayesian Evidence for the chain\"\"\"\n    ...\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.ChainBase.load","title":"<code>load(self)</code>","text":"<p>Load the chain using the engine of your choice</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef load(self):\n    \"\"\"Load the chain using the engine of your choice\"\"\"\n    ...\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.ChainBase.set_alias","title":"<code>set_alias(self)</code>","text":"<p>Set an alias, or shorter name of the chain for quickly reference (useful for long data combinations)</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef set_alias(self):\n    \"\"\"\n    Set an alias, or shorter name of the chain for quickly reference (useful for long data combinations)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.ChainBase.set_label","title":"<code>set_label(self)</code>","text":"<p>Set the label for the chain</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef set_label(self):\n    \"\"\"Set the label for the chain\"\"\"\n    ...\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.ChainBase.set_param_labels","title":"<code>set_param_labels(self, labels)</code>","text":"<p>Set the labels for the parameters</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef set_param_labels(self,labels:list[str]):\n    \"\"\"Set the labels for the parameters\"\"\"\n    ...\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.ChainBase.to_harmonic","title":"<code>to_harmonic(self)</code>","text":"<p>A method that returns the samples and corresponding posterior values in a Harmonic-friendly format.</p> Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef to_harmonic(self):\n    \"\"\"\n    A method that returns the samples and corresponding posterior values in a Harmonic-friendly format.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.base.ChainBase.trace","title":"<code>trace(self, params, *args, **kwargs)</code>","text":"<p>Produce a trace plot of the chain for the requested parameters. i.e. The evolution of the parameter values as a function of the iteration number.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>list</code> <p>A list of sampled (or derived) parameters to inspect</p> required Source code in <code>cosmo_ml_tools/analysis/base.py</code> <pre><code>@abstractmethod\ndef trace(self,params:list,*args,**kwargs):\n    \"\"\"Produce a trace plot of the chain for the requested parameters.\n    i.e. The evolution of the parameter values as a function of the iteration number.\n\n\n    Args:\n        params (list): A list of sampled (or derived) parameters to inspect\n    \"\"\"\n    ...\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.chain","title":"<code>chain</code>","text":""},{"location":"analysis/#cosmo_ml_tools.analysis.chain.CobayaChain","title":"<code> CobayaChain            (MHChain)         </code>","text":"Source code in <code>cosmo_ml_tools/analysis/chain.py</code> <pre><code>class CobayaChain(MHChain):\n\n    def to_harmonic(self,ndim:int,N:int):\n        return convert_to_harmonic(self.filename,ndim,N=N,sampler='cobaya')\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.chain.CobayaChain.to_harmonic","title":"<code>to_harmonic(self, ndim, N)</code>","text":"<p>A method that returns the samples and corresponding posterior values in a Harmonic-friendly format.</p> Source code in <code>cosmo_ml_tools/analysis/chain.py</code> <pre><code>def to_harmonic(self,ndim:int,N:int):\n    return convert_to_harmonic(self.filename,ndim,N=N,sampler='cobaya')\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.chain.MHChain","title":"<code> MHChain            (ChainBase)         </code>","text":"<p>Metropolis-Hastings Base Class</p> Source code in <code>cosmo_ml_tools/analysis/chain.py</code> <pre><code>class MHChain(ChainBase):    \n    \"\"\"\n    Metropolis-Hastings Base Class\n    \"\"\"\n    def load(self,engine:str='getdist'):\n        \"\"\"Load the chain using the specified Engine. Defaults to Getdist.\n\n        Args:\n            engine (str, optional): choice analysis engine. Engines that are currently implemented include: ['getdist'] Defaults to 'getdist'. TODO: include compatibility with `chainconsumer` and `anesthaetic`\n        Raises:\n            NotImplementedError: If the engine is not yet implemented\n\n        Returns:\n            Samples: an instance of the Samples class.\n        \"\"\"\n        if engine=='getdist':\n            return loadMCSamples(self._root+self.fn,self.gd_settings)\n        else:\n            raise NotImplementedError\n\n    def to_harmonic(self):\n        return NotImplementedError\n\n    def getInfo(self):\n        return NotImplementedError    \n\n    def getTable(self, params: list):\n        return NotImplementedError\n\n    def set_param_labels(self,labels:list[str]):\n        return NotImplementedError\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.chain.MHChain.getInfo","title":"<code>getInfo(self)</code>","text":"<p>Print a summary of useful information on the chain.</p> Source code in <code>cosmo_ml_tools/analysis/chain.py</code> <pre><code>def getInfo(self):\n    return NotImplementedError    \n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.chain.MHChain.getTable","title":"<code>getTable(self, params)</code>","text":"<p>Print a latex table with the mean and 68% CL.</p> Source code in <code>cosmo_ml_tools/analysis/chain.py</code> <pre><code>def getTable(self, params: list):\n    return NotImplementedError\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.chain.MHChain.load","title":"<code>load(self, engine='getdist')</code>","text":"<p>Load the chain using the specified Engine. Defaults to Getdist.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <code>str</code> <p>choice analysis engine. Engines that are currently implemented include: ['getdist'] Defaults to 'getdist'. TODO: include compatibility with <code>chainconsumer</code> and <code>anesthaetic</code></p> <code>'getdist'</code> <p>Exceptions:</p> Type Description <code>NotImplementedError</code> <p>If the engine is not yet implemented</p> <p>Returns:</p> Type Description <code>Samples</code> <p>an instance of the Samples class.</p> Source code in <code>cosmo_ml_tools/analysis/chain.py</code> <pre><code>def load(self,engine:str='getdist'):\n    \"\"\"Load the chain using the specified Engine. Defaults to Getdist.\n\n    Args:\n        engine (str, optional): choice analysis engine. Engines that are currently implemented include: ['getdist'] Defaults to 'getdist'. TODO: include compatibility with `chainconsumer` and `anesthaetic`\n    Raises:\n        NotImplementedError: If the engine is not yet implemented\n\n    Returns:\n        Samples: an instance of the Samples class.\n    \"\"\"\n    if engine=='getdist':\n        return loadMCSamples(self._root+self.fn,self.gd_settings)\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.chain.MHChain.set_param_labels","title":"<code>set_param_labels(self, labels)</code>","text":"<p>Set the labels for the parameters</p> Source code in <code>cosmo_ml_tools/analysis/chain.py</code> <pre><code>def set_param_labels(self,labels:list[str]):\n    return NotImplementedError\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.chain.MHChain.to_harmonic","title":"<code>to_harmonic(self)</code>","text":"<p>A method that returns the samples and corresponding posterior values in a Harmonic-friendly format.</p> Source code in <code>cosmo_ml_tools/analysis/chain.py</code> <pre><code>def to_harmonic(self):\n    return NotImplementedError\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.chain.MontePythonChain","title":"<code> MontePythonChain            (MHChain)         </code>","text":"Source code in <code>cosmo_ml_tools/analysis/chain.py</code> <pre><code>class MontePythonChain(MHChain):\n\n    def to_harmonic(self,ndim:int,N:int):\n        return convert_to_harmonic(self.filename,ndim,N=N,sampler='montepython')\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.chain.MontePythonChain.to_harmonic","title":"<code>to_harmonic(self, ndim, N)</code>","text":"<p>A method that returns the samples and corresponding posterior values in a Harmonic-friendly format.</p> Source code in <code>cosmo_ml_tools/analysis/chain.py</code> <pre><code>def to_harmonic(self,ndim:int,N:int):\n    return convert_to_harmonic(self.filename,ndim,N=N,sampler='montepython')\n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.chain.NSChain","title":"<code> NSChain            (ChainBase)         </code>","text":"<p>Nested-Sampling Base Class.</p> Source code in <code>cosmo_ml_tools/analysis/chain.py</code> <pre><code>class NSChain(ChainBase):\n    \"\"\"\n    Nested-Sampling Base Class.\n    \"\"\"\n    pass    \n</code></pre>"},{"location":"analysis/#cosmo_ml_tools.analysis.chain.convert_to_harmonic","title":"<code>convert_to_harmonic(chain_fn, ndim, N=4, sampler='cobaya', ignore=0.3)</code>","text":"<p>Helper function to convert a set of chains into a Harmonic-friendly format</p> <p>Parameters:</p> Name Type Description Default <code>chain_fn</code> <code>str</code> <p>the location of the chains on the disk, where chain_fn is the root for all the chains (and .param_names files)</p> required <code>ndim</code> <code>int</code> <p>Number of sampled (free parameters)</p> required <code>N</code> <code>int</code> <p>Number of chains {chain_fn}__i.txt with i from 1 to N. Defaults to 4.</p> <code>4</code> <code>sampler</code> <code>str</code> <p>specifies sampler used to compute the samples, useful for the format. Defaults to 'cobaya'.</p> <code>'cobaya'</code> <code>ignore</code> <code>float</code> <p>The fraction of samples to reject as burn-in. Defaults to 0.3.</p> <code>0.3</code> <p>Returns:</p> Type Description <code>tuple[list,list]</code> <p>a tuple with the samples and log-posterior values in a Harmonic-compatible format</p> Source code in <code>cosmo_ml_tools/analysis/chain.py</code> <pre><code>def convert_to_harmonic(chain_fn:str,ndim:int,N:int=4,sampler:str='cobaya',ignore:float=0.3)-&gt; tuple[list,list]:\n    \"\"\"\n    Helper function to convert a set of chains into a Harmonic-friendly format\n\n    Args:\n        chain_fn (str): the location of the chains on the disk, where chain_fn is the root for all the chains (and .param_names files)\n        ndim (int): Number of sampled (free parameters)\n        N (int, optional): Number of chains {chain_fn}__i.txt with i from 1 to N. Defaults to 4.\n        sampler (str, optional): specifies sampler used to compute the samples, useful for the format. Defaults to 'cobaya'.\n        ignore (float, optional): The fraction of samples to reject as burn-in. Defaults to 0.3.\n\n    Returns:\n        tuple[list,list]: a tuple with the samples and log-posterior values in a Harmonic-compatible format\n    \"\"\"\n    #Load individual chains\n    chains={f'chain{i}': np.loadtxt(f'{chain_fn}.{i}.txt') for i in range(1,N)}\n\n    # Determine the smaller of them and determine burn-in\n    min_len=np.min([chain.shape[0] for chain in chains.values()])\n    burn_in=int(ignore * min_len)\n\n    # Reshape them into harmonic-friendly format\n    if sampler=='cobaya':\n        samples=np.array([chain[burn_in:min_len,2:ndim+2] for chain in chains.values()]).reshape((N,min_len-burn_in,ndim))\n        lnprob=-np.array([chain[burn_in:min_len,1] for chain in chains.values()]).reshape((N,min_len-burn_in))\n\n    #TODO: Implement Montepython compatibility (Should check which columns give lnprob and whether the sampled params are first)\n    elif sampler=='montepython':\n        print('Sorry, Montepython not yet implemented!')\n        return\n\n    else:\n        print('Sorry, sampler not recognized or not yet implemented!')\n        return\n\n    return samples, lnprob\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#cosmo_ml_tools.common.bye_world","title":"<code>bye_world()</code>","text":"<p>Prints \"Bye World!\" to the console.</p> Source code in <code>cosmo_ml_tools/common.py</code> <pre><code>def bye_world():\n    \"\"\"Prints \"Bye World!\" to the console.\n    \"\"\"\n    print(\"Bye World!\")\n</code></pre>"},{"location":"common/#cosmo_ml_tools.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>cosmo_ml_tools/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\n    \"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/rcalderonb6/cosmo-ml-tools/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>cosmo-ml-tools could always use more documentation, whether as part of the official cosmo-ml-tools docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/rcalderonb6/cosmo-ml-tools/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up cosmo_ml_tools for local development.</p> <ol> <li> <p>Fork the cosmo_ml_tools repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/cosmo-ml-tools.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv cosmo_ml_tools\n$ cd cosmo_ml_tools/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 cosmo_ml_tools tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/rcalderonb6/cosmo-ml-tools/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"cosmo_ml_tools/","title":"cosmo_ml_tools module","text":"<p>Main module.</p>"},{"location":"cosmology/","title":"Cosmology module","text":"<p>Cosmology module.</p>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.base","title":"<code>base</code>","text":""},{"location":"cosmology/#cosmo_ml_tools.cosmology.base.BoltzmannBase","title":"<code> BoltzmannBase            (ABC)         </code>","text":"<p>Abstract Base Class for the Boltzmann Solver class</p> Source code in <code>cosmo_ml_tools/cosmology/base.py</code> <pre><code>class BoltzmannBase(ABC):\n    \"\"\"\n    Abstract Base Class for the Boltzmann Solver class\n    \"\"\"\n\n    @property\n    def name(self)-&gt;None:\n        self._name\n\n    @abstractmethod\n    def getInfo(self) -&gt; None:\n        \"\"\"\n        Print general information about the current Cosmology\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update(self,**kwargs) -&gt; None:\n        \"\"\"\n        Update the values of the cosmological parameters with the provided dictionary and recompute observables.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def compute(self) -&gt; None:\n        \"\"\"\n        (Re)-compute the observables for the chosen cosmology\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def plot(self, observables: list[str],*args,**kwargs) -&gt; None:\n        \"\"\"\n        Plot one or more of the requested output observables\n\n        Args:\n            observables (list[str]): One of the output observables requested to Class. e.g. P(k), Cl's...\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def store(self,filename) -&gt; None:\n        \"\"\"\n        Store the requested outputs in a given folder\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def empty(self) -&gt; None:\n        \"\"\"\n        Clean up structure\n        \"\"\"\n        ...\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.base.BoltzmannBase.compute","title":"<code>compute(self)</code>","text":"<p>(Re)-compute the observables for the chosen cosmology</p> Source code in <code>cosmo_ml_tools/cosmology/base.py</code> <pre><code>@abstractmethod\ndef compute(self) -&gt; None:\n    \"\"\"\n    (Re)-compute the observables for the chosen cosmology\n    \"\"\"\n    ...\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.base.BoltzmannBase.empty","title":"<code>empty(self)</code>","text":"<p>Clean up structure</p> Source code in <code>cosmo_ml_tools/cosmology/base.py</code> <pre><code>@abstractmethod\ndef empty(self) -&gt; None:\n    \"\"\"\n    Clean up structure\n    \"\"\"\n    ...\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.base.BoltzmannBase.getInfo","title":"<code>getInfo(self)</code>","text":"<p>Print general information about the current Cosmology</p> Source code in <code>cosmo_ml_tools/cosmology/base.py</code> <pre><code>@abstractmethod\ndef getInfo(self) -&gt; None:\n    \"\"\"\n    Print general information about the current Cosmology\n    \"\"\"\n    ...\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.base.BoltzmannBase.plot","title":"<code>plot(self, observables, *args, **kwargs)</code>","text":"<p>Plot one or more of the requested output observables</p> <p>Parameters:</p> Name Type Description Default <code>observables</code> <code>list[str]</code> <p>One of the output observables requested to Class. e.g. P(k), Cl's...</p> required Source code in <code>cosmo_ml_tools/cosmology/base.py</code> <pre><code>@abstractmethod\ndef plot(self, observables: list[str],*args,**kwargs) -&gt; None:\n    \"\"\"\n    Plot one or more of the requested output observables\n\n    Args:\n        observables (list[str]): One of the output observables requested to Class. e.g. P(k), Cl's...\n    \"\"\"\n    ...\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.base.BoltzmannBase.store","title":"<code>store(self, filename)</code>","text":"<p>Store the requested outputs in a given folder</p> Source code in <code>cosmo_ml_tools/cosmology/base.py</code> <pre><code>@abstractmethod\ndef store(self,filename) -&gt; None:\n    \"\"\"\n    Store the requested outputs in a given folder\n    \"\"\"\n    ...\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.base.BoltzmannBase.update","title":"<code>update(self, **kwargs)</code>","text":"<p>Update the values of the cosmological parameters with the provided dictionary and recompute observables.</p> Source code in <code>cosmo_ml_tools/cosmology/base.py</code> <pre><code>@abstractmethod\ndef update(self,**kwargs) -&gt; None:\n    \"\"\"\n    Update the values of the cosmological parameters with the provided dictionary and recompute observables.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.classy","title":"<code>classy</code>","text":""},{"location":"cosmology/#cosmo_ml_tools.cosmology.classy.Classy","title":"<code> Classy            (BoltzmannBase)         </code>","text":"<p>Base Class for the Boltzmann solver Class and its extensions</p> Source code in <code>cosmo_ml_tools/cosmology/classy.py</code> <pre><code>class Classy(BoltzmannBase):\n    \"\"\"Base Class for the Boltzmann solver Class and its extensions\"\"\"\n\n    def __init__(self,info:str|dict|None=None,cosmo=None,other_info=dict|None,verbose:int=0,name:str='name') -&gt; None:\n        \"\"\"A wrapper for the Boltzmann solvers Class and its extensions.\n\n        Args:\n            info (str | dict): a string pointing to a .ini/.yaml file or python dictionary with the desired class settings/parameters\n            other_info (dict|None, optional): another set of settings passed to class (e.g. precision settings). Defaults to None.\n            verbose (int, optional): Print useful information for debugging purposes. Defaults to 0.\n            name (str, optional): Give a name to the instance of the class.\n        \"\"\"\n\n        self._clean_state = True\n        self._name = name\n\n        # Handle the info variable according to the type and return a dictionary\n        info=initialize_helper(info)\n\n        if cosmo is None:\n            self.cosmo=get_classy(info,other_info=other_info)\n        else:\n            self.cosmo=cosmo\n            self.update(info)\n\n        self._H_units = {'1/Mpc' : 1, \n                         'km/s/Mpc' : C_KMS,\n                         'dimensionless': 1 / self.cosmo.Hubble(0)}\n\n    def Hubble(self,z:float|np.ndarray,units:str='km/s/Mpc'):\n        H=np.array([self.cosmo.Hubble(zi) for zi in z]) if isinstance(z,np.ndarray) else self.cosmo.Hubble(z)\n        return self._H_units[units] * H\n\n    def alpha(self,which:str='M'):\n        return self._alphas[which]\n\n    def compute(self):\n        self.cosmo.compute()\n\n    def empty(self):\n        self.cosmo.empty()  \n        self.cosmo.cleanup_struct()\n\n    def update(self,info:dict) -&gt; None:\n        \"\"\"\n        Update the values of the cosmological parameters with the provided dictionary and recompute observables.\n        \"\"\"\n        self.cosmo.set(info)\n        self.compute()\n        self._clean_state=False\n\n    def store(self):\n        pass\n\n    def getInfo(self):\n        pass\n\n    def plot(self,observables:list[str],ax=None):\n        pass\n\n    def _background(self):\n        return self.cosmo.get_background()\n\n    def _alphas(self):\n        return get_alphas(self.cosmo)\n\n    def Omega_of_z(self,z:float|np.ndarray,component:str):\n        DE_density={'Modified Gravity':self.background['(.)rho_smg'],'Scalar Field':self.background['(.)rho_scf'],'Cosmological Constant':self.cosmo.Omega_Lambda,'Fluid':self.background['(.)rho_fld']}\n        densities={'cdm':self.background['(.)rho_cdm'],'c':self.background['(.)rho_cdm'],\n           'b':self.background['(.)rho_b'],'cb':self.background['(.)rho_cdm']+self.background['(.)rho_b'],\n           'm':self.background['(.)rho_cdm']+self.background['(.)rho_b']+self.background['(.)rho_ur'],'ur':self.background['(.)rho_ur'],\n           'k':self.Omega_k*(1+z)**2/self.Hubble(0,units='dimensionless'),'g':self.background['(.)rho_g'],\n           'de':DE_density[self.DE_type],\n           }\n        Omega_of_z = densities[component.lower()] / self.rho_crit\n        return Omega_of_z\n\n    @property\n    def z(self):\n        return self.background['z']\n\n    @property\n    def rho_crit(self):\n        return self.background['(.)rho_crit']\n\n    @property\n    def background(self):\n        return self._background()\n\n    @property\n    def Cls(self,ell_factor=True,lensed=True,units='muK2'):\n        return get_Cl(self.cosmo,ell_factor=ell_factor,lensed=lensed,units=units)\n\n    @property\n    def H0(self):\n        return 1e2*self.cosmo.h()\n\n    @property\n    def Omega_g(self):\n        return self.cosmo.Omega_g()\n\n    @property\n    def Omega_m(self):\n        return self.cosmo.Omega_m()\n\n    @property\n    def Omega_b(self):\n        return self.cosmo.Omega_b()\n\n    @property\n    def Omega_c(self):\n        return self.cosmo.Omega0_cdm()\n\n    @property\n    def Omega_cdm(self):\n        return self.cosmo.Omega0_cdm()\n\n    @property\n    def Omega_k(self):\n        return self.cosmo.Omega0_k()\n\n    @property\n    def Omega_DE(self):\n        Omega_DE={'Modified Gravity':self.background['(.)rho_smg'],\n                     'Scalar Field':self.background['(.)rho_scf'],\n                     'Cosmological Constant':self.cosmo.Omega_Lambda,\n                     'Fluid':self.background['(.)rho_fld']}\n        return Omega_DE[self.DE_type]\n\n    @property\n    def rdrag(self):\n        return self.background['comov.snd.hrz.']\n\n    @property\n    def _is_fluid(self)-&gt;bool:\n        if 'Omega_smg' in self.info.keys():\n            return (self.info['Omega_Lambda']==0 and self.info['Omega_smg']==0)\n        else:\n            return (self.info['Omega_Lambda']==0 and self.info['Omega_scf']==0)\n\n    @property\n    def _is_scf(self)-&gt;bool:\n        if 'Omega_smg' in self.info.keys():\n            return False\n        else:\n            return (self.info['Omega_Lambda']==0 and self.info['Omega_fld']==0)\n\n    @property\n    def _is_smg(self)-&gt;bool:\n        if 'Omega_smg' in self.info.keys():\n            return (self.info['Omega_Lambda']==0 and self.info['Omega_fld']==0)\n        else:\n            return False\n\n    @property\n    def DE_type(self):\n        return self._get_DE_type()  \n\n    def _get_DE_type(self)-&gt;str:\n        DE_type='Cosmological Constant'\n        if self._is_fluid:\n            DE_type='Fluid'\n        elif self._is_smg:\n            DE_type='Modified Gravity'\n        elif self._is_scf:\n            DE_type='Scalar Field'        \n        return DE_type      \n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.classy.Classy.__init__","title":"<code>__init__(self, info=None, cosmo=None, other_info=dict | None, verbose=0, name='name')</code>  <code>special</code>","text":"<p>A wrapper for the Boltzmann solvers Class and its extensions.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>str | dict</code> <p>a string pointing to a .ini/.yaml file or python dictionary with the desired class settings/parameters</p> <code>None</code> <code>other_info</code> <code>dict|None</code> <p>another set of settings passed to class (e.g. precision settings). Defaults to None.</p> <code>dict | None</code> <code>verbose</code> <code>int</code> <p>Print useful information for debugging purposes. Defaults to 0.</p> <code>0</code> <code>name</code> <code>str</code> <p>Give a name to the instance of the class.</p> <code>'name'</code> Source code in <code>cosmo_ml_tools/cosmology/classy.py</code> <pre><code>def __init__(self,info:str|dict|None=None,cosmo=None,other_info=dict|None,verbose:int=0,name:str='name') -&gt; None:\n    \"\"\"A wrapper for the Boltzmann solvers Class and its extensions.\n\n    Args:\n        info (str | dict): a string pointing to a .ini/.yaml file or python dictionary with the desired class settings/parameters\n        other_info (dict|None, optional): another set of settings passed to class (e.g. precision settings). Defaults to None.\n        verbose (int, optional): Print useful information for debugging purposes. Defaults to 0.\n        name (str, optional): Give a name to the instance of the class.\n    \"\"\"\n\n    self._clean_state = True\n    self._name = name\n\n    # Handle the info variable according to the type and return a dictionary\n    info=initialize_helper(info)\n\n    if cosmo is None:\n        self.cosmo=get_classy(info,other_info=other_info)\n    else:\n        self.cosmo=cosmo\n        self.update(info)\n\n    self._H_units = {'1/Mpc' : 1, \n                     'km/s/Mpc' : C_KMS,\n                     'dimensionless': 1 / self.cosmo.Hubble(0)}\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.classy.Classy.compute","title":"<code>compute(self)</code>","text":"<p>(Re)-compute the observables for the chosen cosmology</p> Source code in <code>cosmo_ml_tools/cosmology/classy.py</code> <pre><code>def compute(self):\n    self.cosmo.compute()\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.classy.Classy.empty","title":"<code>empty(self)</code>","text":"<p>Clean up structure</p> Source code in <code>cosmo_ml_tools/cosmology/classy.py</code> <pre><code>def empty(self):\n    self.cosmo.empty()  \n    self.cosmo.cleanup_struct()\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.classy.Classy.getInfo","title":"<code>getInfo(self)</code>","text":"<p>Print general information about the current Cosmology</p> Source code in <code>cosmo_ml_tools/cosmology/classy.py</code> <pre><code>def getInfo(self):\n    pass\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.classy.Classy.plot","title":"<code>plot(self, observables, ax=None)</code>","text":"<p>Plot one or more of the requested output observables</p> <p>Parameters:</p> Name Type Description Default <code>observables</code> <code>list[str]</code> <p>One of the output observables requested to Class. e.g. P(k), Cl's...</p> required Source code in <code>cosmo_ml_tools/cosmology/classy.py</code> <pre><code>def plot(self,observables:list[str],ax=None):\n    pass\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.classy.Classy.store","title":"<code>store(self)</code>","text":"<p>Store the requested outputs in a given folder</p> Source code in <code>cosmo_ml_tools/cosmology/classy.py</code> <pre><code>def store(self):\n    pass\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.classy.Classy.update","title":"<code>update(self, info)</code>","text":"<p>Update the values of the cosmological parameters with the provided dictionary and recompute observables.</p> Source code in <code>cosmo_ml_tools/cosmology/classy.py</code> <pre><code>def update(self,info:dict) -&gt; None:\n    \"\"\"\n    Update the values of the cosmological parameters with the provided dictionary and recompute observables.\n    \"\"\"\n    self.cosmo.set(info)\n    self.compute()\n    self._clean_state=False\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.classy.get_Cl","title":"<code>get_Cl(cosmo, ell_factor=True, lensed=True, units='muK2')</code>","text":"<p>Get the (un)lensed total CMB power spectra and lensing power spectrum</p> <p>Parameters:</p> Name Type Description Default <code>cosmo</code> <code>_type_</code> <p>An instance of the Class class</p> required <code>ell_factor</code> <code>bool</code> <p>whether to include the l(l+1)^n factor. Defaults to True.</p> <code>True</code> <code>lensed</code> <code>bool</code> <p>whether to retrieve the lensed- or unlensed-Cl's. Defaults to True.</p> <code>True</code> <code>units</code> <code>str</code> <p>FIRAS normalization to \u00b5K^2. Defaults to 'muK2'.</p> <code>'muK2'</code> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary with the requested Cl's (2 &lt; l &lt;= l_max), in the requested units.</p> Source code in <code>cosmo_ml_tools/cosmology/classy.py</code> <pre><code>def get_Cl(cosmo,ell_factor:bool=True,lensed:bool=True,units:str='muK2') -&gt; dict:\n    \"\"\"Get the (un)lensed total CMB power spectra and lensing power spectrum\n\n    Args:\n        cosmo (_type_): An instance of the Class class\n        ell_factor (bool, optional): whether to include the l(l+1)^n factor. Defaults to True.\n        lensed (bool, optional): whether to retrieve the lensed- or unlensed-Cl's. Defaults to True.\n        units (str, optional): FIRAS normalization to \u00b5K^2. Defaults to 'muK2'.\n\n    Returns:\n        dict: a dictionary with the requested Cl's (2 &lt; l &lt;= l_max), in the requested units.\n    \"\"\"\n    # Set the normalization to Firas T_0 measurements\n    norm = T0_FIRAS**2 if units=='muK2' else 1.\n\n    # Retrieve Cl's from Class\n    Cls=cosmo.raw_cl() if lensed else cosmo.raw_cl()\n\n    # Remove first two multipoles and scale accordingly\n    l=Cls['ell'][2:]\n    if ell_factor:\n        l_factor = {key: l*(l+1) / TWO_PI for key in ['tt','te','et','ee','bb']}\n        l_factor['pp']= (l*(l+1))**2 / TWO_PI\n        l_factor['ell']= 1.\n        l_factor.update({key: (l*(l+1))**(3/2) / TWO_PI for key in ['tp','pt','ep','pe']})\n    else:\n        l_factor={key:1 for key in ['tt','te','et','ee','tp','pt','ep','pe','pp','bb']}\n\n    return  {key: norm * l_factor[key] * val[2:] for key,val in Cls.items()}\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.classy.get_alphas","title":"<code>get_alphas(cosmo)</code>","text":"<p>Get the evolution of the alpha functions from hiclass</p> <p>Parameters:</p> Name Type Description Default <code>cosmo</code> <code>_type_</code> <p>An instance of the hi_class/mochi_class class</p> required <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary containing the evolution of the alpha functions</p> Source code in <code>cosmo_ml_tools/cosmology/classy.py</code> <pre><code>def get_alphas(cosmo) -&gt; dict:\n    \"\"\"Get the evolution of the alpha functions from hiclass\n\n    Args:\n        cosmo (_type_): An instance of the hi_class/mochi_class class\n    Returns:\n        dict: a dictionary containing the evolution of the alpha functions\n    \"\"\"    \n    # Retrieve alpha's from Class\n    b = cosmo.get_background()\n    alphas = {k: b[key] for k,key in zip(['M','B','K','T'],['Mpl_running_smg','braiding_smg','kineticity_smg','tensor_excess_smg'])}\n    alpha_H = b['beyond_horndeski_smg'] if 'beyond_horndeski_smg' in b.keys() else np.zeros_like(b['Mpl_running_smg'])\n    alphas.update({'H':alpha_H})\n    return alphas\n</code></pre>"},{"location":"cosmology/#cosmo_ml_tools.cosmology.classy.get_classy","title":"<code>get_classy(info, other_info=None, verbose=0)</code>","text":"<p>Get an instance of the Class class and compute observables requested in the <code>info</code> dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>dict</code> <p>common settings in a dictionary format</p> required <code>other_info</code> <code>dict | None</code> <p>Additional run-specific/precision settings. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Class instance</code> <p>a Classy object with computations stored in it.</p> Source code in <code>cosmo_ml_tools/cosmology/classy.py</code> <pre><code>def get_classy(info:dict,other_info:dict|None=None,verbose=0):\n    \"\"\"Get an instance of the Class class and compute observables requested in the `info` dictionary.\n\n    Args:\n        info (dict): common settings in a dictionary format\n        other_info (dict | None, optional): Additional run-specific/precision settings. Defaults to None.\n\n    Returns:\n        Class instance: a Classy object with computations stored in it.\n    \"\"\"\n    # m=Class()\n    # m.set(info)\n    # if other_info is not None: m.set(other_info)\n    # m.compute()\n    # return m\n    pass\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install cosmo-ml-tools, run this command in your terminal:</p> <pre><code>pip install cosmo-ml-tools\n</code></pre> <p>This is the preferred method to install cosmo-ml-tools, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install cosmo-ml-tools from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/rcalderonb6/cosmo-ml-tools\n</code></pre>"},{"location":"plots/","title":"Plotting module","text":"<p>The <code>plots</code> module of <code>cosmo-ml-tools</code> contains useful scripts and visualization tools to produce publication-quality plots. </p> <p>Plotting module.</p>"},{"location":"plots/#cosmo_ml_tools.plots.monitor","title":"<code>monitor</code>","text":"<p>Useful scripts to monitor the status of the computations/chains convergence</p>"},{"location":"plots/#cosmo_ml_tools.plots.plot","title":"<code>plot</code>","text":""},{"location":"plots/#cosmo_ml_tools.plots.plot.plot_fill_between","title":"<code>plot_fill_between(x, samples_y, label=None, ax=None, color='gray', lw=2.0, alpha=0.5, quantiles=[2.3, 16, 50, 84, 97.7])</code>","text":"<p>Plot median and quantiles for a given (flatten) array of samples</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>an array with x-values as a numpy array.</p> required <code>samples_y</code> <code>np.ndarray</code> <p>a numpy array with samples for the quantity f=y(x).</p> required <code>label</code> <code>str</code> <p>labels to use in the legend. Defaults to None.</p> <code>None</code> <code>ax</code> <code>_type_</code> <p>a matplotlib axes instance. If None, will create a single plot with default settings. Defaults to None.</p> <code>None</code> <code>color</code> <code>str</code> <p>color for the contours. Defaults to 'gray'.</p> <code>'gray'</code> <code>lw</code> <code>float</code> <p>length-width for the lines. Defaults to 2..</p> <code>2.0</code> <code>alpha</code> <code>float</code> <p>transparency of the contour colors. Defaults to 0.5.</p> <code>0.5</code> <code>quantiles</code> <code>list</code> <p>quantiles of the distribution to plot. Defaults to [2.3, 16, 50, 84, 97.7].</p> <code>[2.3, 16, 50, 84, 97.7]</code> Source code in <code>cosmo_ml_tools/plots/plot.py</code> <pre><code>def plot_fill_between(x : np.ndarray, samples_y: np.ndarray, label: str = None,\n                      ax = None, color: str = 'gray', lw: float = 2., alpha:float = 0.5, quantiles:list=[2.3, 16, 50, 84, 97.7]):\n    \"\"\"\n    Plot median and quantiles for a given (flatten) array of samples\n\n    Args:\n        x (np.ndarray): an array with x-values as a numpy array.\n        samples_y (np.ndarray): a numpy array with samples for the quantity f=y(x).\n        label (str, optional): labels to use in the legend. Defaults to None.\n        ax (_type_, optional): a matplotlib axes instance. If None, will create a single plot with default settings. Defaults to None.\n        color (str, optional): color for the contours. Defaults to 'gray'.\n        lw (float, optional): length-width for the lines. Defaults to 2..\n        alpha (float, optional): transparency of the contour colors. Defaults to 0.5.\n        quantiles (list, optional): quantiles of the distribution to plot. Defaults to [2.3, 16, 50, 84, 97.7].\n    \"\"\"\n    if ax is None:\n        try: \n            import matplotlib.pyplot as plt\n        except ModuleNotFoundError: \n            print('Cannot import matplotlib. Try installing matplotlib before!')\n        fig,ax=plt.subplots()\n\n    qs = np.percentile(samples_y, q=quantiles, axis=0)\n    idx = len(qs) // 2\n    median = qs[idx]\n    for i in range(1, idx + 1):\n        ax.fill_between(x.flatten(), qs[idx - i].flatten(), qs[idx + i].flatten(), color=color, lw=lw, alpha=alpha / i)\n    ax.plot(x, median, label=label, c=color, ls='-', lw=lw)\n</code></pre>"},{"location":"quickstart/","title":"A Quickstart on some of the features of Cosmo-ML-Tools","text":""},{"location":"sampler/","title":"Sampler module","text":"<p>Sampler Module.</p>"},{"location":"sampler/#cosmo_ml_tools.sampler.base","title":"<code>base</code>","text":""},{"location":"sampler/#cosmo_ml_tools.sampler.base.MCBase","title":"<code> MCBase            (ABC)         </code>","text":"<p>Abstract Monte Carlo Base Class</p> Source code in <code>cosmo_ml_tools/sampler/base.py</code> <pre><code>class MCBase(ABC):\n    \"\"\"Abstract Monte Carlo Base Class\"\"\"\n    def __init__(self):\n        ...\n\n    @abstractmethod\n    def run(self,*args,**kwargs):\n        \"\"\"\n        Start the sampling process\n        \"\"\"\n        ...\n\n    @abstractmethod \n    def resume(self,*args,**kwargs):\n        \"\"\"\n        Resume the sampling process\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def trace(self,params:list,*args,**kwargs):\n        \"\"\"\n        Produce a trace plot of the chain. i.e. the evolution of the parameter values as a function of step number\n\n        Args:\n            params (list): A list of parameters to plot.\n\n        Returns:\n            fig: An instance of the matplotlib class\n        \"\"\"\n        ...\n</code></pre>"},{"location":"sampler/#cosmo_ml_tools.sampler.base.MCBase.resume","title":"<code>resume(self, *args, **kwargs)</code>","text":"<p>Resume the sampling process</p> Source code in <code>cosmo_ml_tools/sampler/base.py</code> <pre><code>@abstractmethod \ndef resume(self,*args,**kwargs):\n    \"\"\"\n    Resume the sampling process\n    \"\"\"\n    ...\n</code></pre>"},{"location":"sampler/#cosmo_ml_tools.sampler.base.MCBase.run","title":"<code>run(self, *args, **kwargs)</code>","text":"<p>Start the sampling process</p> Source code in <code>cosmo_ml_tools/sampler/base.py</code> <pre><code>@abstractmethod\ndef run(self,*args,**kwargs):\n    \"\"\"\n    Start the sampling process\n    \"\"\"\n    ...\n</code></pre>"},{"location":"sampler/#cosmo_ml_tools.sampler.base.MCBase.trace","title":"<code>trace(self, params, *args, **kwargs)</code>","text":"<p>Produce a trace plot of the chain. i.e. the evolution of the parameter values as a function of step number</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>list</code> <p>A list of parameters to plot.</p> required <p>Returns:</p> Type Description <code>fig</code> <p>An instance of the matplotlib class</p> Source code in <code>cosmo_ml_tools/sampler/base.py</code> <pre><code>@abstractmethod\ndef trace(self,params:list,*args,**kwargs):\n    \"\"\"\n    Produce a trace plot of the chain. i.e. the evolution of the parameter values as a function of step number\n\n    Args:\n        params (list): A list of parameters to plot.\n\n    Returns:\n        fig: An instance of the matplotlib class\n    \"\"\"\n    ...\n</code></pre>"},{"location":"sampler/#cosmo_ml_tools.sampler.ensemble","title":"<code>ensemble</code>","text":""},{"location":"sampler/#cosmo_ml_tools.sampler.ensemble.EnsembleBase","title":"<code> EnsembleBase            (MCBase)         </code>","text":"<p>Base Class for an Ensemble Sampler.</p> Source code in <code>cosmo_ml_tools/sampler/ensemble.py</code> <pre><code>class EnsembleBase(MCBase):\n    \"\"\"\n    Base Class for an Ensemble Sampler.\n    \"\"\"\n    def __init__(self,ini_file,engine:str,sampler_kwargs:dict):\n        # super().__init__(ini_file,engine,sampler_kwargs)\n        self.info=initialize_helper(ini_file)\n        self.sampler_kwargs=sampler_kwargs\n        self.out_dir=self.info['output'] if 'output' in self.info.keys() else None\n        self._priors=None \n\n    def run(self):\n        self.sampler.run()\n\n    @property\n    def priors(self):\n        return self._priors\n</code></pre>"},{"location":"sampler/#cosmo_ml_tools.sampler.ensemble.EnsembleBase.run","title":"<code>run(self)</code>","text":"<p>Start the sampling process</p> Source code in <code>cosmo_ml_tools/sampler/ensemble.py</code> <pre><code>def run(self):\n    self.sampler.run()\n</code></pre>"},{"location":"sampler/#cosmo_ml_tools.sampler.pocomc","title":"<code>pocomc</code>","text":""},{"location":"sampler/#cosmo_ml_tools.sampler.pocomc.PocoMCBase","title":"<code> PocoMCBase            (EnsembleBase)         </code>","text":"<p>PocoMC Base Class</p> Source code in <code>cosmo_ml_tools/sampler/pocomc.py</code> <pre><code>class PocoMCBase(EnsembleBase):\n    \"\"\"\n    PocoMC Base Class\n    \"\"\"\n    def __init__(self,ini_file:str,engine:str='pocomc',sampler_kwargs=None):\n        super().__init__(ini_file,engine,sampler_kwargs)\n        self._priors=get_priors_from_cobaya(self.info)\n        self._vectorized=True if 'vectorize' in self.sampler_kwargs.keys() else False\n\n        # PocoMC Sampler\n        self.sampler=pc.Sampler(prior=self.priors,\n                                likelihood=self.log_likelihood,\n                                **self.sampler_kwargs)\n\n    def log_likelihood(self,*args,**kw_args):\n        raise NotImplementedError\n\n    @property\n    def logZ(self):\n        logz, logz_err = self.sampler.evidence()\n        return logz\n\n    @property\n    def samples(self):\n        \"\"\" \n        MCMC samples with unit weights\n        \"\"\"\n        samples, _, _ = self.sampler.posterior(resample=True)\n        return samples\n</code></pre>"},{"location":"sampler/#cosmo_ml_tools.sampler.pocomc.PocoMCBase.samples","title":"<code>samples</code>  <code>property</code> <code>readonly</code>","text":"<p>MCMC samples with unit weights</p>"},{"location":"sampler/#cosmo_ml_tools.sampler.pocomc.get_priors_from_cobaya","title":"<code>get_priors_from_cobaya(info)</code>","text":"<p>Generate Priors in PocoMC format from a cobaya-like info dictionary</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>dict</code> <p>priors and settings for the run</p> required <p>Returns:</p> Type Description <code>Prior</code> <p>an instance of the PocoMC.Prior class</p> Source code in <code>cosmo_ml_tools/sampler/pocomc.py</code> <pre><code>def get_priors_from_cobaya(info:dict):\n    \"\"\"\n    Generate Priors in PocoMC format from a cobaya-like info dictionary\n\n    Args:\n        info (dict): priors and settings for the run\n\n    Returns:\n        Prior: an instance of the PocoMC.Prior class\n    \"\"\"\n    priors=[]\n    for parameter,settings in info['params'].items():\n        prior=settings['prior']\n        if 'dist' in prior.keys():\n            if prior['dist']=='norm':\n                loc,scale=[prior[key] for key in ['loc','scale']]\n                priors.append(norm(loc,scale))\n            else:\n                print('Distribution not yet implemented in Cosmo-ML-Tools.')\n        else:\n            lower_bound=prior['min']\n            width=prior['max']-lower_bound\n            priors.append(uniform(lower_bound,width))\n\n    return pc.Prior(priors)\n</code></pre>"},{"location":"stats/","title":"Statistics module","text":""},{"location":"stats/#cosmo_ml_tools.stats.crossing.analytical_fde_from_w","title":"<code>analytical_fde_from_w(z, C0=1, C1=0, C2=0, C3=0, C4=0, C5=0, C6=0)</code>","text":"<p>Compute the integral \\(f_\\mathrm{DE}=\\exp[\\int 3(1+w) d\\ln(1+z)]\\) for a Chebyshev expansion of w(z) up to order 7 (C6)</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>array</code> <p>redshift array</p> required <code>C0</code> <code>int</code> <p>First Chebyshev coefficient. Defaults to 1.</p> <code>1</code> <code>C1</code> <code>int</code> <p>Second Chebyshev coefficient. Defaults to 0.</p> <code>0</code> <code>C2</code> <code>int</code> <p>Third Chebyshev coefficient. Defaults to 0.</p> <code>0</code> <code>C3</code> <code>int</code> <p>Fourth Chebyshev coefficient. Defaults to 0.</p> <code>0</code> <code>C4</code> <code>int</code> <p>Fifth Chebyshev coefficient. Defaults to 0.</p> <code>0</code> <code>C5</code> <code>int</code> <p>Sixth Chebyshev coefficient. Defaults to 0.</p> <code>0</code> <code>C6</code> <code>int</code> <p>Seventh Chebyshev coefficient. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>array</code> <p>corresponding dark energy density evolution \\(f_\\mathrm{DE}(z)\\).</p> Source code in <code>cosmo_ml_tools/stats/crossing.py</code> <pre><code>def analytical_fde_from_w(z,C0=1,C1=0,C2=0,C3=0,C4=0,C5=0,C6=0):\n    r\"\"\"Compute the integral $f_\\mathrm{DE}=\\exp[\\int 3(1+w) d\\ln(1+z)]$ for a Chebyshev expansion of w(z) up to order 7 (C6)\n\n    Args:\n        z (array): redshift array\n        C0 (int, optional): First Chebyshev coefficient. Defaults to 1.\n        C1 (int, optional): Second Chebyshev coefficient. Defaults to 0.\n        C2 (int, optional): Third Chebyshev coefficient. Defaults to 0.\n        C3 (int, optional): Fourth Chebyshev coefficient. Defaults to 0.\n        C4 (int, optional): Fifth Chebyshev coefficient. Defaults to 0.\n        C5 (int, optional): Sixth Chebyshev coefficient. Defaults to 0.\n        C6 (int, optional): Seventh Chebyshev coefficient. Defaults to 0.\n\n    Returns:\n        array: corresponding dark energy density evolution $f_\\mathrm{DE}(z)$.\n    \"\"\"\n    zmax=z.max()\n    return (1 + z)**((3*zmax*(-128*C4*zmax + zmax**2*(-256*C4 - 8*(C2 + 20*C4)*zmax + 2*(C1 - 4*(C2 + 4*C4))*zmax**2 - (-1 + C0 - C1 + C2 + C4)*zmax**3 + C3*(2 + zmax)*(16 + zmax*(16 + zmax))) + C5*(2 + zmax)*(256 + zmax*(4 + zmax)*(128 + zmax*(44 + zmax)))) - 3*C6*(8 + zmax*(8 + zmax))*(256 + zmax*(512 + zmax*(320 + zmax*(64 + zmax)))))/zmax**6)/np.exp((2*z*(256*C6*(-60 + z*(30 + z*(-20 + z*(15 + 2*z*(-6 + 5*z))))) + 64*(C5 - 12*C6)*(60 + z*(-30 + z*(20 + 3*z*(-5 + 4*z))))*zmax + 80*(C4 - 10*C5 + 54*C6)*(-12 + z*(6 + z*(-4 + 3*z)))*zmax**2 + 40*(C3 - 8*C4 + 35*C5 - 112*C6)*(6 + z*(-3 + 2*z))*zmax**3 + 30*(C2 - 6*C3 + 20*C4 - 50*C5 + 105*C6)*(-2 + z)*zmax**4 + 15*(C1 - 4*C2 + 9*C3 - 16*C4 + 25*C5 - 36*C6)*zmax**5))/(5.*zmax**6))\n</code></pre>"},{"location":"stats/#cosmo_ml_tools.stats.crossing.get_Chebyshev_T","title":"<code>get_Chebyshev_T(x, Ci)</code>","text":"<p>Get a Chebyshev Polynomial expansion for a given set of coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float | np.ndarray</code> <p>an array of values where to compute</p> required <code>Ci</code> <code>list | np.ndarray</code> <p>list or array with Chebyshev coefficients</p> required <p>Returns:</p> Type Description <code>callable</code> <p>A callable to be evualuated at points <code>x</code></p> Source code in <code>cosmo_ml_tools/stats/crossing.py</code> <pre><code>def get_Chebyshev_T(x:float|np.ndarray,Ci:list|np.ndarray):\n    r\"\"\"\n    Get a Chebyshev Polynomial expansion for a given set of coefficients.\n\n    Args:\n        x (float | np.ndarray): an array of values where to compute\n        Ci (list | np.ndarray): list or array with Chebyshev coefficients\n\n    Returns:\n        callable: A callable to be evualuated at points `x`\n    \"\"\"\n    cheb = Chebyshev(Ci,domain=(x[0],x[-1]))\n    return cheb\n</code></pre>"},{"location":"stats/#cosmo_ml_tools.stats.crossing.get_samples_crossing_fde","title":"<code>get_samples_crossing_fde(z, samples_gd, order=4)</code>","text":"<p>Get the dark energy evolution \\(f_\\mathrm{DE}(z)\\) from MCMC samples of the Chebyshev coefficients</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>np.ndarray</code> <p>array with redshift values</p> required <code>samples_gd</code> <code>dict</code> <p>a dictionary with getdist instances. They keys in the dictionary are used as labels for each chains.</p> required <code>order</code> <code>int</code> <p>The order of the polynomial expansion of \\(f_\\mathrm{DE}(z)=\\rho_{\\rm DE}()\\). Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary containing the corresponding samples of fde(z) for each chain.</p> Source code in <code>cosmo_ml_tools/stats/crossing.py</code> <pre><code>def get_samples_crossing_fde(z:np.ndarray,samples_gd:dict,order:int=4) -&gt; dict:\n    r\"\"\"Get the dark energy evolution $f_\\mathrm{DE}(z)$ from MCMC samples of the Chebyshev coefficients\n\n    Args:\n        z (np.ndarray): array with redshift values\n        samples_gd (dict): a dictionary with getdist instances. They keys in the dictionary are used as labels for each chains.\n        order (int, optional): The order of the polynomial expansion of $f_\\mathrm{DE}(z)=\\rho_{\\rm DE}()$. Defaults to 4.\n\n    Returns:\n        dict: a dictionary containing the corresponding samples of fde(z) for each chain.\n    \"\"\"\n    coeffs=[f'C{i}' for i in range(order)]\n    samples_hyper={label: np.array([samples[c] for c in coeffs]).T for label,samples in samples_gd.items()}\n    crossing_fde={label: np.array([get_Chebyshev_T(z,Ci)(z) for Ci in tqdm(samples)]) for label,samples in samples_hyper.items()}\n    return crossing_fde\n</code></pre>"},{"location":"stats/#cosmo_ml_tools.stats.crossing.get_samples_crossing_w","title":"<code>get_samples_crossing_w(z, samples_gd, order=4, return_fde=True)</code>","text":"<p>Get the dark energy evolution</p> <p>$ f_{\\mathrm{DE}}(z) = \\frac{\\rho_{\\mathrm{DE}}(z)}{\\rho_{\\mathrm{DE},0}} $</p> <p>for a given set of Chebyshev coefficients in the expansion of </p> <p>$ w(z) = \\sum_{i=0}^{N} c_i T_i(x) $</p> Source code in <code>cosmo_ml_tools/stats/crossing.py</code> <pre><code>def get_samples_crossing_w(z,samples_gd:dict,order:int=4,return_fde:bool=True) -&gt; dict:\n    r\"\"\"\n    Get the dark energy evolution\n\n    $ f_{\\mathrm{DE}}(z) = \\frac{\\rho_{\\mathrm{DE}}(z)}{\\rho_{\\mathrm{DE},0}} $\n\n    for a given set of Chebyshev coefficients in the expansion of \n\n    $ w(z) = \\sum_{i=0}^{N} c_i T_i(x) $\n\n    Returns:\n\n    \"\"\"\n\n    coeffs=[f'C{i}' for i in range(order)]\n    samples_hyper={label: np.array([samples[c] for c in coeffs]).T for label,samples in samples_gd.items()}\n    crossing_w={label: np.array([-get_Chebyshev_T(z,Ci)(z) for Ci in tqdm(samples)]) for label,samples in samples_hyper.items()}\n    crossing_fde={lbl: np.array([analytical_fde_from_w(z,*Ci) for Ci in tqdm(samples)]) for lbl,samples in samples_hyper.items()}\n    if return_fde:\n        return crossing_w,crossing_fde\n    return crossing_w\n</code></pre>"},{"location":"stats/#cosmo_ml_tools.stats.acquisition.ExpectedImprovement","title":"<code>ExpectedImprovement(rng_key, model, X, xi=0.01, maximize=False, n=1)</code>","text":"<p>Expected Improvement</p> Source code in <code>cosmo_ml_tools/stats/acquisition.py</code> <pre><code>def ExpectedImprovement(rng_key: jnp.ndarray, model: Type[GaussianProcessJax],\n       X: jnp.ndarray, xi: float = 0.01,\n       maximize: bool = False, n: int = 1) -&gt; jnp.ndarray:\n    \"\"\"\n    Expected Improvement\n    \"\"\"\n    y_mean, y_sampled = model.predict(rng_key, X, n=n)\n    if n &gt; 1:\n        y_sampled = y_sampled.reshape(n * y_sampled.shape[0], -1)\n    mean, sigma = y_sampled.mean(0), y_sampled.std(0)\n    u = (mean - y_mean.max() - xi) / sigma\n    u = -u if not maximize else u\n    normal = dist.Normal(jnp.zeros_like(u), jnp.ones_like(u))\n    ucdf = normal.cdf(u)\n    updf = jnp.exp(normal.log_prob(u))\n    return sigma * (updf + u * ucdf) \n</code></pre>"},{"location":"stats/#cosmo_ml_tools.stats.acquisition.ThompsonSampling","title":"<code>ThompsonSampling(rng_key, model, posterior_samples, X, n=1)</code>","text":"<p>Thompson sampling</p> Source code in <code>cosmo_ml_tools/stats/acquisition.py</code> <pre><code>def ThompsonSampling(rng_key: jnp.ndarray,\n             model: Type[GaussianProcessJax],\n             posterior_samples: Dict[str, jnp.ndarray],\n             X: jnp.ndarray, n: int = 1) -&gt; jnp.ndarray:\n    \"\"\"Thompson sampling\"\"\"\n    posterior_samples = model.get_samples()\n    idx = jra.randint(rng_key, (1,), 0, len(posterior_samples[\"k_length\"]))\n    samples = {k: v[idx] for (k, v) in posterior_samples.items()}\n    _, tsample = model.predict(rng_key, X, samples, n)\n    if n &gt; 1:\n        tsample = tsample.mean(1)\n    return tsample.squeeze()\n</code></pre>"},{"location":"stats/#cosmo_ml_tools.stats.acquisition.UncertaintyExploration","title":"<code>UncertaintyExploration(rng_key, model, X, n=1)</code>","text":"<p>Uncertainty-based exploration (aka kriging)</p> Source code in <code>cosmo_ml_tools/stats/acquisition.py</code> <pre><code>def UncertaintyExploration(rng_key: jnp.ndarray,\n       model: Type[GaussianProcessJax],\n       X: jnp.ndarray, n: int = 1) -&gt; jnp.ndarray:\n    \"\"\"Uncertainty-based exploration (aka kriging)\"\"\"\n    _, y_sampled = model.predict(rng_key, X, n=n)\n    return y_sampled.var(0)\n</code></pre>"},{"location":"stats/#cosmo_ml_tools.stats.acquisition.UpperConfidenceBound","title":"<code>UpperConfidenceBound(rng_key, model, X, beta=0.25, maximize=False, n=1)</code>","text":"<p>Upper confidence bound</p> Source code in <code>cosmo_ml_tools/stats/acquisition.py</code> <pre><code>def UpperConfidenceBound(rng_key: jnp.ndarray, model: Type[GaussianProcessJax],\n        X: jnp.ndarray, beta: float = .25,\n        maximize: bool = False, n: int = 1) -&gt; jnp.ndarray:\n    \"\"\"\n    Upper confidence bound\n    \"\"\"\n    _, y_sampled = model.predict(rng_key, X, n=n)\n    if n &gt; 1:\n        y_sampled = y_sampled.reshape(n * y_sampled.shape[0], -1)\n    mean, var= y_sampled.mean(0), y_sampled.var(0)\n    delta = jnp.sqrt(beta * var)\n    if maximize:\n        return mean + delta\n    return mean - delta \n</code></pre>"},{"location":"stats/#cosmo_ml_tools.stats.likelihood.Likelihood","title":"<code> Likelihood            (LikelihoodBase)         </code>","text":"<p>General Likelihood Class</p> Source code in <code>cosmo_ml_tools/stats/likelihood.py</code> <pre><code>class Likelihood(LikelihoodBase):\n    \"\"\"General Likelihood Class\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def ln_prob(self,*args,**kwargs):\n        return -0.5 * self.chi(*args,**kwargs)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use cosmo-ml-tools in a project:</p> <pre><code>import cosmo_ml_tools\n</code></pre>"},{"location":"utils/","title":"Utilities module","text":"<p>Utilities module.</p>"},{"location":"utils/#cosmo_ml_tools.utils.file","title":"<code>file</code>","text":""},{"location":"utils/#cosmo_ml_tools.utils.file.initialize_helper","title":"<code>initialize_helper(ini_file, engine='class')</code>","text":"<p>Helper function commonly used in the various init methods.</p> <p>Parameters:</p> Name Type Description Default <code>ini_file</code> <code>str|dict</code> <p>The path to an initialization file. Supports .yaml file from Cobaya and .param files from Montepython, as well as .bestfit files from Getdist.</p> required <code>engine</code> <code>str</code> <p>The engine to assist. Defaults to 'class'.</p> <code>'class'</code> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary with the relevant information contained in the ini_file.</p> Source code in <code>cosmo_ml_tools/utils/file.py</code> <pre><code>def initialize_helper(ini_file:str|dict,engine='class') -&gt; dict:\n    \"\"\"Helper function commonly used in the various __init__ methods.\n\n    Args:\n        ini_file (str|dict): The path to an initialization file. Supports .yaml file from Cobaya and .param files from Montepython, as well as .bestfit files from Getdist.\n        engine (str): The engine to assist. Defaults to 'class'.\n\n    Returns:\n        dict: a dictionary with the relevant information contained in the ini_file.\n    \"\"\"\n    _classy = True if engine in ['classy','class'] else False\n    _file_loader={'yaml': partial(load_yaml,class_format=_classy),'ini':load_ini,'bf':load_bf,'mp':load_param}\n\n    # If its a string, load the corresponding file from the disk according to its format\n    if isinstance(ini_file, str):\n        fmt=_get_ini_file_type(ini_file)\n        return _file_loader[fmt](ini_file)\n\n    # If its a dictionary, its already in the correct format and we do nothing\n    elif not isinstance(ini_file, dict):\n        raise FileTypeNotSupported \n</code></pre>"},{"location":"utils/#cosmo_ml_tools.utils.file.load_ini","title":"<code>load_ini(filename)</code>","text":"<p>Read a CLASS <code>.ini</code> file, returning a dictionary of parameters.</p>"},{"location":"utils/#cosmo_ml_tools.utils.file.load_ini--parameters","title":"Parameters","text":"<p>filename : str     The name of an existing parameter file to load, or one included as part of the CLASS source.</p>"},{"location":"utils/#cosmo_ml_tools.utils.file.load_ini--returns","title":"Returns","text":"<p>ini : dict     The input parameters loaded from file.</p> Source code in <code>cosmo_ml_tools/utils/file.py</code> <pre><code>def load_ini(filename):\n    \"\"\"\n    Read a CLASS ``.ini`` file, returning a dictionary of parameters.\n\n    Parameters\n    ----------\n    filename : str\n        The name of an existing parameter file to load, or one included as part of the CLASS source.\n\n    Returns\n    -------\n    ini : dict\n        The input parameters loaded from file.\n    \"\"\"\n    # also look in data dir\n    filename = _find_file(filename)\n\n    params = {}\n    with open(filename, 'r') as file:\n\n        # loop over lines\n        for j, line in enumerate(file):\n            if not line: continue\n\n            # skip any commented lines with #\n            if '#' in line: line = line[line.index('#') + 1:]\n\n            # must have an equals sign to be valid\n            if \"=\" not in line: continue\n\n            # extract key and value pairs\n            fields = line.split('=')\n            if len(fields) != 2:\n                import warnings\n                warnings.warn('Skipping line number {}: \"{}\"'.format(j, line))\n                continue\n            params[fields[0].strip()] = fields[1].strip()\n\n    return params\n</code></pre>"},{"location":"utils/#cosmo_ml_tools.utils.file.load_precision","title":"<code>load_precision(filename)</code>","text":"<p>Load a CLASS <code>.pre</code> file, and return a dictionary of input parameters.</p>"},{"location":"utils/#cosmo_ml_tools.utils.file.load_precision--parameters","title":"Parameters","text":"<p>filename : str     .ini file to load passed to class.</p>"},{"location":"utils/#cosmo_ml_tools.utils.file.load_precision--returns","title":"Returns","text":"<p>pre : dict     The precision parameters loaded from the file.</p> Source code in <code>cosmo_ml_tools/utils/file.py</code> <pre><code>def load_precision(filename):\n    \"\"\"\n    Load a CLASS ``.pre`` file, and return a dictionary of input parameters.\n\n    Parameters\n    ----------\n    filename : str\n        .ini file to load passed to class.\n\n    Returns\n    -------\n    pre : dict\n        The precision parameters loaded from the file.\n    \"\"\"\n    return load_ini(filename)\n</code></pre>"},{"location":"utils/#cosmo_ml_tools.utils.file.write_bf","title":"<code>write_bf(bestfit_point, param_names=None, out_filename='chain.bestfit', override=False)</code>","text":"<p>Write a GetDist-like .bestfit file</p> <p>Parameters:</p> Name Type Description Default <code>bestfit_point</code> <code>np.ndarray</code> <p>array with bestfit values for the parameters.</p> required <code>param_names</code> <code>list[str]|None</code> <p>a list with the parameter names. Defaults to None, in which case the labels param1,param2,etc are given.</p> <code>None</code> <code>out_filename</code> <code>str</code> <p>description. Defaults to 'chain.bestfit'.</p> <code>'chain.bestfit'</code> <code>override</code> <code>bool,optional</code> <p>check for existing .bestfit file and override if True. Defaults to False.</p> <code>False</code> Source code in <code>cosmo_ml_tools/utils/file.py</code> <pre><code>def write_bf(bestfit_point:np.ndarray,param_names:list[str]|None=None,out_filename:str='chain.bestfit',override:bool=False):\n    \"\"\"\n    Write a GetDist-like .bestfit file\n\n    Args:\n        bestfit_point (np.ndarray): array with bestfit values for the parameters.\n        param_names (list[str]|None, optional): a list with the parameter names. Defaults to None, in which case the labels param1,param2,etc are given.\n        out_filename (str, optional): _description_. Defaults to 'chain.bestfit'.\n        override (bool,optional): check for existing .bestfit file and override if True. Defaults to False.\n    \"\"\"\n    if param_names is None: param_names=[f'param{i}' for i in range(len(bestfit_point))]\n    if override:\n        np.savetxt(out_filename,bestfit_point,header=param_names)\n    else:\n        print('Found existing .bestfile file. Choose another output location/filename or set `override=True` if you want to override the previously stored .bestfit file')\n</code></pre>"},{"location":"utils/#cosmo_ml_tools.utils.table","title":"<code>table</code>","text":""},{"location":"utils/#cosmo_ml_tools.utils.table.get_latex_table","title":"<code>get_latex_table(samples, parameters, param_labels=None)</code>","text":"<p>Get a latex table with mean and 68% credible intervals constraints for a given set of chains and cosmological parameters.</p> <p>samples: dictionary, a dictionary with getdist instances with the chains.  The corresponding dictionary keys are used as labels.</p> <p>parameters: list, a list with parameter names you want to include in the table</p> <p>param_labels: list (optional), a list with latex names for each of the requested parameters.  If none, its name on the chain is used.</p> Source code in <code>cosmo_ml_tools/utils/table.py</code> <pre><code>def get_latex_table(samples,parameters,param_labels=None):\n    \"\"\"\n    Get a latex table with mean and 68% credible intervals constraints for a given set of chains and cosmological parameters.\n\n    samples: dictionary, a dictionary with getdist instances with the chains. \n    The corresponding dictionary keys are used as labels.\n\n    parameters: list, a list with parameter names you want to include in the table\n\n    param_labels: list (optional), a list with latex names for each of the requested parameters. \n    If none, its name on the chain is used.\n\n    \"\"\"\n    Nparams=len(parameters)\n    cols='l'+'c' * Nparams\n\n    print(r'\\begin{table*}[t]')\n    print(r'\\caption{68\\% credible intervals for the cosmological parameters,\\\n        using various dataset combinations.','\\n',r'\\vspace{0.5em}}')\n    print(r'\\label{tab:tab_label}')\n    print(r'\\centering')\n    print(r'\\small')\n    print(r'\\resizebox{0.95\\textwidth}{!}{')\n    print(r'\\begin{tabular}'+r'{%s}'%cols)\n    print(r'\\toprule')\n    print(r'\\toprule')\n    line='Dataset'\n    params=parameters if param_labels is None else param_labels\n    for p in params:\n        line+=f' &amp; {p}'\n    print(line+r' \\\\')\n    print(r'\\midrule[1.5pt]')\n    for lbl,chain in samples.items():\n        line=f'{lbl}'   \n        for p in parameters:\n            stats=chain.getInlineLatex(p,limit=1).split('=')[1].strip()\n            line+=f' &amp; ${stats}$ '\n        print(line+r' \\\\')\n        if lbl != list(samples.keys())[-1]: print(r'\\midrule')\n    print(r'\\toprule')\n    print(r'\\toprule')\n    print(r'\\end{tabular}}')\n    print(r'\\end{table*}')\n</code></pre>"},{"location":"workflows/","title":"Workflows module","text":"<p>Workflows module.</p>"},{"location":"workflows/#cosmo_ml_tools.workflows.evidence","title":"<code>evidence</code>","text":"<p>Compute the Bayesian Evidence from MCMC samples using  the Harmonic Mean estimator and Normalizing Flows. We use the python package Harmonic and this basic  example workflow heavily relies on their tutorial.</p>"},{"location":"examples/gp/","title":"Gp","text":"<p>In this example, we will use a Gaussian Process model to \"reconstruct\" a given function $y$ from noisy observations $y=f(x)+\\epsilon$.</p> In\u00a0[1]: Copied! <pre>import numpy as np\n</pre> import numpy as np"},{"location":"examples/gp/#gaussian-process-regression","title":"Gaussian Process Regression\u00b6","text":""},{"location":"examples/model_selection/","title":"Model selection","text":"In\u00a0[\u00a0]: Copied!"},{"location":"examples/model_selection/#bayesian-evidence-computation-and-model-selection-with-cobaya-harmonic","title":"Bayesian Evidence Computation and Model Selection with <code>Cobaya</code> &amp; <code>Harmonic</code>\u00b6","text":""}]}